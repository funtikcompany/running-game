<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>Running Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        @keyframes swipe {
            0% { transform: translateX(-20px); }
            50% { transform: translateX(20px); }
            100% { transform: translateX(-20px); }
        }
    </style>
</head>
<body>
    <!-- –¢—É—Ç–æ—Ä—ñ–∞–ª –ø–µ—Ä–µ–¥ –ø–æ—á–∞—Ç–∫–æ–º –≥—Ä–∏ -->
    <div id="tutorial" style="position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); display:flex; align-items:center; justify-content:center; flex-direction:column; color:#fff; z-index:10;">
        <div style="animation: swipe 1s infinite;">üëÜ</div>
        <div>SWIPE TO MOVE</div>
    </div>

    <!-- –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –±—ñ–±–ª—ñ–æ—Ç–µ–∫ -->
<!-- –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –±—ñ–±–ª—ñ–æ—Ç–µ–∫ -->
<script src="https://cdn.jsdelivr.net/npm/three@0.124.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.124.0/examples/js/loaders/GLTFLoader.js"></script>


    <!-- –û—Å–Ω–æ–≤–Ω–∏–π —Å–∫—Ä–∏–ø—Ç -->
    <script>
        // –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Å—Ü–µ–Ω–∏
        const scene = new THREE.Scene();

        // –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫–∞–º–µ—Ä–∏
        const camera = new THREE.PerspectiveCamera(100, window.innerWidth/window.innerHeight, 0.2, 1000);
        camera.position.z = 20;
        camera.position.y = 2;

        // –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // –î–æ–¥–∞–≤–∞–Ω–Ω—è –æ—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è
        const ambientLight = new THREE.AmbientLight(0x85d3fb, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0x85d3fb, 0.5);
        directionalLight.position.set(0, 5, 5);
        scene.add(directionalLight);


        // –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
        let player; // –ó–º—ñ–Ω–Ω–∞ –¥–ª—è –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è –º–æ–¥–µ–ª—ñ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
        let mixer; // –ó–º—ñ–Ω–Ω–∞ –¥–ª—è AnimationMixer
        let clock = new THREE.Clock(); // –ì–æ–¥–∏–Ω–Ω–∏–∫ –¥–ª—è –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è —á–∞—Å—É –≤ –∞–Ω—ñ–º–∞—Ü—ñ—ó
        let runAction; // –ê–Ω—ñ–º–∞—Ü—ñ—ó —Å—Ç—Ä–∏–±–∫–∞ —Ç–∞ –±—ñ–≥—É
        const loader = new THREE.GLTFLoader();
        loader.load(
            'Stickman.glb', // –ü–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—è, —â–æ —Ñ–∞–π–ª –∑–Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –≤ —Ç—ñ–π —Å–∞–º—ñ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó
            function (gltf) {
                player = gltf.scene;
                player.scale.set(.8, .8, .8); // –ú–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è –º–æ–¥–µ–ª—ñ –ø—Ä–∏ –Ω–µ–æ–±—Ö—ñ–¥–Ω–æ—Å—Ç—ñ
                player.position.y = 0; // –í—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–æ—á–∞—Ç–∫–æ–≤–æ—ó –ø–æ–∑–∏—Ü—ñ—ó –ø–æ –æ—Å—ñ Y
                player.rotation.y = Math.PI; // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ –º–æ–¥–µ–ª—å, —è–∫—â–æ –≤–æ–Ω–∞ –¥–∏–≤–∏—Ç—å—Å—è –≤ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π –±—ñ–∫
                scene.add(player);

                // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è AnimationMixer
                mixer = new THREE.AnimationMixer(player);

                // –î–æ–¥–∞—î–º–æ –∞–Ω—ñ–º–∞—Ü—ñ—ó –∑ –º–æ–¥–µ–ª—ñ
                const animations = gltf.animations;
                console.log('–î–æ—Å—Ç—É–ø–Ω—ñ –∞–Ω—ñ–º–∞—Ü—ñ—ó:', animations);

                animations.forEach((clip, index) => {
                    console.log(`–ê–Ω—ñ–º–∞—Ü—ñ—è ${index}:`, clip.name);
                });

                // –ü–æ—à—É–∫ –∞–Ω—ñ–º–∞—Ü—ñ–π –∑–∞ —ñ–º–µ–Ω–∞–º–∏
                // const jumpClip = THREE.AnimationClip.findByName(animations, 'Victory');
                const runClip = THREE.AnimationClip.findByName(animations, 'Run');

                if (runClip) {
                    // jumpAction = mixer.clipAction(jumpClip);
                    runAction = mixer.clipAction(runClip);

                    // –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –¥–ª—è –∫–æ—Ä–µ–∫—Ç–Ω–æ–≥–æ –ø–µ—Ä–µ—Ö–æ–¥—É –º—ñ–∂ –∞–Ω—ñ–º–∞—Ü—ñ—è–º–∏
                    runAction.enabled = true; // –°–ø–æ—á–∞—Ç–∫—É –≤–∏–º–∏–∫–∞—î–º–æ –±—ñ–≥
                    runAction.setLoop(THREE.LoopRepeat); // –ó—Ä–æ–±–∏–º–æ –±—ñ–≥ –ø–æ–≤—Ç–æ—Ä—é–≤–∞–Ω–∏–º

                    // jumpAction.clampWhenFinished = true; // –ó—É–ø–∏–Ω—è—î–º–æ –∞–Ω—ñ–º–∞—Ü—ñ—é –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è
                    // jumpAction.loop = THREE.LoopOnce; // –°—Ç—Ä–∏–±–æ–∫ –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –æ–¥–∏–Ω —Ä–∞–∑

                    // –ü–æ—á–∏–Ω–∞—î–º–æ –∑—ñ —Å—Ç—Ä–∏–±–∫–∞
                    // jumpAction.play();
                    runAction.play();
                    mixer.addEventListener('finished', (event) => {
                        if (event.action === jumpAction) {
                            // –ü—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è —Å—Ç—Ä–∏–±–∫–∞ –≤–∫–ª—é—á–∞—î–º–æ –±—ñ–≥
                            runAction.enabled = true;
                        
                        }
                    });
                } else {
                    console.error('–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–Ω–∞–π—Ç–∏ –Ω–µ–æ–±—Ö—ñ–¥–Ω—ñ –∞–Ω—ñ–º–∞—Ü—ñ—ó.');
                }
            },
            undefined,
            function (error) {
                console.error('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –º–æ–¥–µ–ª—ñ:', error);
            }
        );

                // –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ç—Ä–µ–∫—É
    // –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ç—Ä–µ–∫—É
            let track; // –ó–º—ñ–Ω–Ω–∞ –¥–ª—è –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è –º–æ–¥–µ–ª—ñ —Ç—Ä–µ–∫—É
            const trackLoader = new THREE.GLTFLoader();
            let trackLength;
            const tracks = [];

// Load the track model
    trackLoader.load(
        'TrackFloor.glb',
        function (gltf) {
            track = gltf.scene;
            track.scale.set(2, 10, 10);
            track.position.set(0, 0, 0);
            track.rotation.set(0, 0, 0);

            // Compute the length of the track model
            const bbox = new THREE.Box3().setFromObject(track);
            trackLength = bbox.max.z - bbox.min.z;

            // Change material for visibility testing
            track.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshStandardMaterial({ color: 0xffffff });
                }
            });

            // Add the initial track to the scene
            scene.add(track);
            tracks.push(track); // Add to the tracks array

            // Create initial additional tracks to cover initial distance
            createAdditionalTrack();
            createAdditionalTrack();
            createAdditionalTrack();

            console.log('Track loaded successfully:', track);
        },
        undefined,
        function (error) {
            console.error('Error loading the track model:', error);
        }
    );

// Function to create and position additional tracks
function createAdditionalTrack() {
    const lastTrack = tracks[tracks.length - 1]; // Get the last track added
    const clonedTrack = lastTrack.clone();
    clonedTrack.position.set(
        lastTrack.position.x,
        lastTrack.position.y,
        lastTrack.position.z - trackLength
    );
    scene.add(clonedTrack);
    tracks.push(clonedTrack);
}

// Function to update track positions based on player's position
function updateTrackPosition(playerPositionZ) {
    const lastTrack = tracks[tracks.length - 1];

    // If the player is within half the track length from the last track, add a new one
    if (playerPositionZ - lastTrack.position.z < trackLength / 2) {
        createAdditionalTrack();
    }

    // Optional: Remove tracks that are far behind the player to save memory
    if (tracks.length > 5) {
        const firstTrack = tracks[0];
        if (playerPositionZ - firstTrack.position.z > trackLength * 2) {
            scene.remove(firstTrack);
            tracks.shift();
        }
    }
}

// In your animate function, make sure to call updateTrackPosition
function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();
    if (mixer) mixer.update(delta);

    if (player) {
        // Move the player forward
        player.position.z -= speed;
        camera.position.z = player.position.z + 5;
        camera.position.x = player.position.x;

        // Update track positions
        updateTrackPosition(player.position.z);

        // ... rest of your code ...
    }

    renderer.render(scene, camera);
}
    const brains = [];

    const brainLoader = new THREE.GLTFLoader();
    const brainColors = [0xffa500, 0x0000ff, 0x800080];
    const lanes = [-3, 0, 3]; // –¢—Ä–∏ —Ä—è–¥–∏ –ø–æ –æ—Å—ñ X

    function createBrain(xPosition, zPosition, color) {
        brainLoader.load(
            'Brain.glb',
            function (gltf) {
                const brain = gltf.scene;
                brain.scale.set(2, 2, 2);
                brain.position.set(xPosition, 0.5, zPosition);

                // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –∫–æ–ª—ñ—Ä —É userData
                brain.userData.color = new THREE.Color(color);

                brain.traverse((child) => {
                    if (child.isMesh) {
                        child.material.color.set(color);
                    }
                });
                scene.add(brain);
                brains.push(brain);
            },
            undefined,
            function (error) {
                console.error('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –º–æ–¥–µ–ª—ñ –º–æ–∑–∫—É:', error);
            }
        );
    }


        function createBrainsSequence(zPosition) {
            // –í–∏–ø–∞–¥–∫–æ–≤–æ –≤–∏–±–∏—Ä–∞—î–º–æ —Ä—è–¥–æ–∫ (–¥–æ—Ä—ñ–∂–∫—É)
            const laneIndex = Math.floor(Math.random() * lanes.length);
            const xPosition = lanes[laneIndex];

            // –í–∏–ø–∞–¥–∫–æ–≤–æ –≤–∏–±–∏—Ä–∞—î–º–æ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –º—ñ–∑–∫—ñ–≤ —É –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ (–≤—ñ–¥ 2 –¥–æ 5)
            const brainCountInSequence = Math.floor(Math.random() * 2) + 1; // 2, 3, 4 –∞–±–æ 5

            // –í–∏–ø–∞–¥–∫–æ–≤–æ –≤–∏–±–∏—Ä–∞—î–º–æ –∫–æ–ª—ñ—Ä –¥–ª—è –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ
            const color = brainColors[Math.floor(Math.random() * brainColors.length)];

            // –ì–µ–Ω–µ—Ä—É—î–º–æ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –º—ñ–∑–∫—ñ–≤
            for (let i = 0; i < brainCountInSequence; i++) {
                const brainZPosition = zPosition - i * 7; // –í—ñ–¥—Å—Ç–∞–Ω—å –º—ñ–∂ –º—ñ–∑–∫–∞–º–∏ –≤ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ

                // –°—Ç–≤–æ—Ä—é—î–º–æ –º—ñ–∑–æ–∫
                createBrain(xPosition, brainZPosition, color);
            }
        }

        let speed = 0.2;

        let brainCount = 0;

// –§—É–Ω–∫—Ü—ñ—è –¥–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Å–ø—Ä–∞–π—Ç–∞
function createTextSprite(message) {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 128;
    const context = canvas.getContext('2d');
    context.font = 'Bold 80px Arial';
    context.fillStyle = 'rgba(255,255,255,1.0)';
    context.textAlign = 'center';
    context.fillText(message, canvas.width / 2, canvas.height / 2 + 30);

    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;

    const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.scale.set(2, 1, 1);

    // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –∫–∞–Ω–≤–∞—Å —Ç–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –ø–æ–¥–∞–ª—å—à–æ–≥–æ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è
    sprite.userData.canvas = canvas;
    sprite.userData.context = context;

    return sprite;
}

// –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Å–ø—Ä–∞–π—Ç–∞ –∑ –ø–æ—á–∞—Ç–∫–æ–≤–∏–º –∑–Ω–∞—á–µ–Ω–Ω—è–º 0
const brainCountSprite = createTextSprite('0');
scene.add(brainCountSprite);

function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();
    if (mixer) mixer.update(delta);

    if (player) {
        player.position.z -= speed;
        camera.position.z = player.position.z + 5;
        camera.position.x = player.position.x;

        // –û–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–æ–∑–∏—Ü—ñ—ó —Å–ø—Ä–∞–π—Ç–∞ –Ω–∞–¥ –≥–æ–ª–æ–≤–æ—é
        brainCountSprite.position.set(player.position.x, player.position.y + 3, player.position.z);

        if (Math.random() < 0.02) {
            createBrainsSequence(player.position.z - 50);
        }

        for (let i = brains.length - 1; i >= 0; i--) {
            const brain = brains[i];
            if (brain.position.z > player.position.z) {
                continue;
            }
            if (brain.position.distanceTo(player.position) < 1) {
                // –ó–º—ñ–Ω–∞ –∫–æ–ª—å–æ—Ä—É –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
                player.traverse(function(child) {
                    if (child.isMesh) {
                        let childMaterials = Array.isArray(child.material) ? child.material : [child.material];
                        childMaterials.forEach(function(material) {
                            if (material.color) {
                                material.color.set(brain.userData.color);
                            }
                        });
                    }
                });

                // –ó–±—ñ–ª—å—à–µ–Ω–Ω—è –ª—ñ—á–∏–ª—å–Ω–∏–∫–∞ –º—ñ–∑–∫—ñ–≤
                brainCount++;

                // –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Ç–µ–∫—Å—Ç—É –Ω–∞ —Å–ø—Ä–∞–π—Ç—ñ
                updateTextSprite(brainCountSprite, brainCount.toString());

                // –í–∏–¥–∞–ª–µ–Ω–Ω—è –º—ñ–∑–∫—É
                scene.remove(brain);
                brains.splice(i, 1);
            }
        }
    }

    renderer.render(scene, camera);
}

function updateTextSprite(sprite, message) {
    const context = sprite.userData.context;
    const canvas = sprite.userData.canvas;

    // –û—á–∏—â–µ–Ω–Ω—è –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–≥–æ —Ç–µ–∫—Å—Ç—É
    context.clearRect(0, 0, canvas.width, canvas.height);

    // –ú–∞–ª—é—î–º–æ –Ω–æ–≤–∏–π —Ç–µ–∫—Å—Ç
    context.fillText(message, canvas.width / 2, canvas.height / 2 + 30);

    // –ü–æ–≤—ñ–¥–æ–º–ª—è—î–º–æ, —â–æ —Ç–µ–∫—Å—Ç—É—Ä—É –ø–æ—Ç—Ä—ñ–±–Ω–æ –æ–Ω–æ–≤–∏—Ç–∏
    sprite.material.map.needsUpdate = true;
}

        // –£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–º —á–µ—Ä–µ–∑ —Å–≤–∞–π–ø
        let isDragging = false;
        let previousMousePosition = {
            x: 0,
            y: 0
        };

        function handleMove(deltaX) {
            if (player) {
                player.position.x += deltaX * 0.01;
                // –û–±–º–µ–∂–µ–Ω–Ω—è —Ä—É—Ö—É –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –ø–æ –æ—Å—ñ X
                player.position.x = Math.max(Math.min(player.position.x, 4.5), -4.5);
            }
        }

        // –î–ª—è –¥–µ—Å–∫—Ç–æ–ø—ñ–≤
        document.addEventListener('mousedown', function(e) {
            isDragging = true;
            previousMousePosition.x = e.clientX;
        });

        document.addEventListener('mousemove', function(e) {
            if (isDragging) {
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x
                };
                handleMove(deltaMove.x);
                previousMousePosition.x = e.clientX;
            }
        });

        document.addEventListener('mouseup', function(e) {
            isDragging = false;
        });

        // –î–ª—è –º–æ–±—ñ–ª—å–Ω–∏—Ö –ø—Ä–∏—Å—Ç—Ä–æ—ó–≤
        document.addEventListener('touchstart', function(e) {
            isDragging = true;
            previousMousePosition.x = e.touches[0].clientX;
        });

        document.addEventListener('touchmove', function(e) {
            if (isDragging) {
                const deltaMove = {
                    x: e.touches[0].clientX - previousMousePosition.x
                };
                handleMove(deltaMove.x);
                previousMousePosition.x = e.touches[0].clientX;
            }
        });

        document.addEventListener('touchend', function(e) {
            isDragging = false;
        });

        // –¢—É—Ç–æ—Ä—ñ–∞–ª –ø–µ—Ä–µ–¥ –ø–æ—á–∞—Ç–∫–æ–º –≥—Ä–∏
        const tutorial = document.getElementById('tutorial');

        tutorial.addEventListener('click', () => {
            tutorial.style.display = 'none';
            // –ü–æ—á–∏–Ω–∞—î–º–æ –≥—Ä—É
            animate();
        });

        // –û–±—Ä–æ–±–∫–∞ –∑–º—ñ–Ω–∏ —Ä–æ–∑–º—ñ—Ä—É –≤—ñ–∫–Ω–∞
        window.addEventListener('resize', function() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
